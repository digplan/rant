import FS, { fstat } from 'node:fs'
import crypto from 'node:crypto'
import assert from 'node:assert'
import http from 'node:http'

const debug = process.env.debug || global?.debug

const log = console.log.bind(console)

const isJSON = s => {
  try{ return JSON.parse(s) } catch(e) {}
}

const get = async (url, options = {}, after = x=>x) => {
  if(!options.headers) options.headers = {}
  if(!options.headers.accept) options.headers.accept = 'application/json'
  if(debug) console.log('get() >>> ', url, options, after)
  if (!url.match(/^http\:/)) url = `https://${url}`
  const f = await fetch(url, options)
  const s = await f.text()
  const ret = after(isJSON(s) || s)
  if (global.debug) console.log('get() returned ' + JSON.stringify(ret))
  return ret
}

const save = (o, fn) => {
  FS.writeFileSync(`./${fn}`, JSON.stringify(o, null, 2))
  return fn
}

const read = (fn) => {
  try {
    return FS.readFileSync(`./${fn}`, 'utf8')
  } catch (e) {}
}

const load = (fn) => {
  return isJSON(read(fn))
}

const exists = (fn) => {
  return FS.existsSync(fn)
}

const del = (fn) => {
  FS.unlinkSync(fn)
  return fn
}

const hash = (s) => {
   return crypto.createHash('sha256').update(s).digest('hex')
}

const te = (a, b) => {
   return assert.equal(a, b)
}

const tde = (a, b) => {
    return assert.deepEqual(a, b)
}

const tm = (a, b) => {
  assert.match(a, b)
  return a
}

const wait = async (ms) => {
  return new Promise((r)=>setTimeout(r.bind('', 'wait over'), ms))
}

const appendLn = (s, fn) => FS.appendFileSync(fn, `\r\n${s}`)
const saveES = (o, fn) => {
  FS.writeFileSync(fn, 'export default ' + JSON.stringify(o, null, 2))
  return fn
}

export { log, isJSON, get, save, read, load, exists, del, hash, te, tde, tm, wait, appendLn, saveES }
